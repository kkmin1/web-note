{
  "id": "ea4362df-bfb7-4109-ba11-5c7604bc8875",
  "title": "python : predator-prey model",
  "content": "# This example describe how to integrate ODEs with scipy.integrate module, and how\n# to use the matplotlib module to plot trajectories, direction fields and other\n# useful information.\n# \n# == Presentation of the Lokta-Volterra Model ==\n# \n# We will have a look at the Lokta-Volterra model, also known as the\n# predator-prey equations, which are a pair of first order, non-linear, differential\n# equations frequently used to describe the dynamics of biological systems in\n# which two species interact, one a predator and one its prey. They were proposed\n# independently by Alfred J. Lotka in 1925 and Vito Volterra in 1926:\n# du/dt =  a*u -   b*u*v\n# dv/dt = -c*v + d*b*u*v \n# \n# with the following notations:\n# \n# *  u: number of preys (for example, rabbits)\n# \n# *  v: number of predators (for example, foxes)  \n#   \n# * a, b, c, d are constant parameters defining the behavior of the population:    \n# \n#   + a is the natural growing rate of rabbits, when there's no fox\n# \n#   + b is the natural dying rate of rabbits, due to predation\n# \n#   + c is the natural dying rate of fox, when there's no rabbit\n# \n#   + d is the factor describing how many caught rabbits let create a new fox\n# \n# We will use X=[u, v] to describe the state of both populations.\n# \n# Definition of the equations:\n# \nfrom numpy import *\nimport pylab as p\n\n# Definition of parameters \na = 1.\nb = 0.1\nc = 1.5\nd = 0.75\n\ndef dX_dt(X, t=0):\n    \"\"\" Return the growth rate of fox and rabbit populations. \"\"\"\n    return array([ a*X[0] -   b*X[0]*X[1] ,  \n                  -c*X[1] + d*b*X[0]*X[1] ])\n# \n# === Population equilibrium ===\n# \n# Before using !SciPy to integrate this system, we will have a closer look on \n# position equilibrium. Equilibrium occurs when the growth rate is equal to 0.\n# This gives two fixed points:\n# \nX_f0 = array([     0. ,  0.])\nX_f1 = array([ c/(d*b), a/b])\nall(dX_dt(X_f0) == zeros(2) ) and all(dX_dt(X_f1) == zeros(2)) # => True \n# \n# === Stability of the fixed points ===\n# Near theses two points, the system can be linearized:\n# dX_dt = A_f*X where A is the Jacobian matrix evaluated at the corresponding point.\n# We have to define the Jacobian matrix:\n# \ndef d2X_dt2(X, t=0):\n    \"\"\" Return the Jacobian matrix evaluated in X. \"\"\"\n    return array([[a -b*X[1],   -b*X[0]     ],\n                  [b*d*X[1] ,   -c +b*d*X[0]] ])  \n# \n# So, near X_f0, which represents the extinction of both species, we have:\n# A_f0 = d2X_dt2(X_f0)                    # >>> array([[ 1. , -0. ],\n#                                         #            [ 0. , -1.5]])\n# \n# Near X_f0, the number of rabbits increase and the population of foxes decrease.\n# The origin is a [http://en.wikipedia.org/wiki/Saddle_point saddle point].\n# \n# Near X_f1, we have:\nA_f1 = d2X_dt2(X_f1)                    # >>> array([[ 0.  , -2.  ],\n                                        #            [ 0.75,  0.  ]])\n\n# whose eigenvalues are +/- sqrt(c*a).j:\nlambda1, lambda2 = linalg.eigvals(A_f1) # >>> (1.22474j, -1.22474j)\n\n# They are imaginary number, so the fox and rabbit populations are periodic and\n# their period is given by:\nT_f1 = 2*pi/abs(lambda1)                # >>> 5.130199\n#         \n# == Integrating the ODE using scipy.integate ==\n# \n# Now we will use the scipy.integrate module to integrate the ODEs.\n# This module offers a method named odeint, very easy to use to integrate ODEs:\n# \nfrom scipy import integrate\n\nt = linspace(0, 15,  1000)              # time\nX0 = array([10, 5])                     # initials conditions: 10 rabbits and 5 foxes  \n\nX, infodict = integrate.odeint(dX_dt, X0, t, full_output=True)\ninfodict['message']                     # >>> 'Integration successful.'\n# \n# `infodict` is optional, and you can omit the `full_output` argument if you don't want it.\n# Type \"info(odeint)\" if you want more information about odeint inputs and outputs.\n# \n# We can now use Matplotlib to plot the evolution of both populations:\n# \nrabbits, foxes = X.T\n\nf1 = p.figure()\np.plot(t, rabbits, 'r-', label='Rabbits')\np.plot(t, foxes  , 'b-', label='Foxes')\np.grid()\np.legend(loc='best')\np.xlabel('time')\np.ylabel('population')\np.title('Evolution of fox and rabbit populations')\nf1.savefig('rabbits_and_foxes_1.png')\n# \n# \n# The populations are indeed periodic, and their period is near to the T_f1 we calculated.\n# \n# == Plotting direction fields and trajectories in the phase plane ==\n# \n# We will plot some trajectories in a phase plane for different starting\n# points between X__f0 and X_f1.\n# \n# We will use matplotlib's colormap to define colors for the trajectories.\n# These colormaps are very useful to make nice plots.\n# Have a look at [http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps ShowColormaps] if you want more information.\n# \nvalues  = linspace(0.3, 0.9, 5)                          # position of X0 between X_f0 and X_f1\nvcolors = p.cm.autumn_r(linspace(0.3, 1., len(values)))  # colors for each trajectory\n\nf2 = p.figure()\n\n#-------------------------------------------------------\n# plot trajectories\nfor v, col in zip(values, vcolors): \n    X0 = v * X_f1                               # starting point\n    X = integrate.odeint( dX_dt, X0, t)         # we don't need infodict here\n    p.plot( X[:,0], X[:,1], lw=3.5*v, color=col, label='X0=(%.f, %.f)' % ( X0[0], X0[1]) )\n\n#-------------------------------------------------------\n# define a grid and compute direction at each point\nymax = p.ylim(ymin=0)[1]                        # get axis limits\nxmax = p.xlim(xmin=0)[1] \nnb_points   = 20                      \n\nx = linspace(0, xmax, nb_points)\ny = linspace(0, ymax, nb_points)\n\nX1 , Y1  = meshgrid(x, y)                       # create a grid\nDX1, DY1 = dX_dt([X1, Y1])                      # compute growth rate on the gridt\nM = (hypot(DX1, DY1))                           # Norm of the growth rate \nM[ M == 0] = 1.                                 # Avoid zero division errors \nDX1 /= M                                        # Normalize each arrows\nDY1 /= M                                  \n\n#-------------------------------------------------------\n# Drow direction fields, using matplotlib 's quiver function\n# I choose to plot normalized arrows and to use colors to give information on\n# the growth speed\np.title('Trajectories and direction fields')\nQ = p.quiver(X1, Y1, DX1, DY1, M, pivot='mid', cmap=p.cm.jet)\np.xlabel('Number of rabbits')\np.ylabel('Number of foxes')\np.legend()\np.grid()\np.xlim(0, xmax)\np.ylim(0, ymax)\nf2.savefig('rabbits_and_foxes_2.png')\n# \n# \n# We can see on this graph that an intervention on fox or rabbit populations can\n# have non intuitive effects. If, in order to decrease the number of rabbits,\n# we introduce foxes, this can lead to an increase of rabbits in the long run,\n# if that intervention happens at a bad moment.\n# \n# \n# == Plotting contours ==\n# \n# We can verify that the function IF defined below remains constant along a trajectory:\n# \ndef IF(X):\n    u, v = X\n    return u**(c/a) * v * exp( -(b/a)*(d*u+v) )\n\n# We will verify that IF remains constant for different trajectories\nfor v in values: \n    X0 = v * X_f1                               # starting point\n    X = integrate.odeint( dX_dt, X0, t)         \n    I = IF(X.T)                                 # compute IF along the trajectory\n    I_mean = I.mean()\n    delta = 100 * (I.max()-I.min())/I_mean\n    print 'X0=(%2.f,%2.f) => I ~ %.1f |delta = %.3G %%' % (X0[0], X0[1], I_mean, delta)\n\n# >>> X0=( 6, 3) => I ~ 20.8 |delta = 6.19E-05 %\n#     X0=( 9, 4) => I ~ 39.4 |delta = 2.67E-05 %\n#     X0=(12, 6) => I ~ 55.7 |delta = 1.82E-05 %\n#     X0=(15, 8) => I ~ 66.8 |delta = 1.12E-05 %\n#     X0=(18, 9) => I ~ 72.4 |delta = 4.68E-06 %\n# \n# Potting iso-contours of IF can be a good representation of trajectories,\n# without having to integrate the ODE\n# \n#-------------------------------------------------------\n# plot iso contours\nnb_points = 80                              # grid size \n\nx = linspace(0, xmax, nb_points)    \ny = linspace(0, ymax, nb_points)\n\nX2 , Y2  = meshgrid(x, y)                   # create the grid\nZ2 = IF([X2, Y2])                           # compute IF on each point\n\nf3 = p.figure()\nCS = p.contourf(X2, Y2, Z2, cmap=p.cm.Purples_r, alpha=0.5)\nCS2 = p.contour(X2, Y2, Z2, colors='black', linewidths=2. )\np.clabel(CS2, inline=1, fontsize=16, fmt='%.f')\np.grid()\np.xlabel('Number of rabbits')\np.ylabel('Number of foxes')\np.ylim(1, ymax)\np.xlim(1, xmax)\np.title('IF contours')\nf3.savefig('rabbits_and_foxes_3.png')\np.show()\n# \n# \n# # vim: set et sts=4 sw=4:",
  "color": "default",
  "labels": [
    "53f6ec6c-841a-4ea4-a381-5d977aafd7cf",
    "a57425d6-bf5f-4849-8870-5e88e53e4b54",
    "962773d3-36bd-4ad9-ae7c-a7d4dedcca9a"
  ],
  "pinned": false,
  "archived": true,
  "inTrash": false,
  "reminder": null,
  "createdAt": "2020-10-01T13:19:09.538000",
  "updatedAt": "2023-02-28T08:37:54.213000"
}